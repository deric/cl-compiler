<<
/* parser.dlg -- DLG Description of scanner
 *
 * Generated from: cl.g
 *
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-2001
 * Purdue University Electrical Engineering
 * With AHPCRC, University of Minnesota
 * ANTLR Version 1.33MR33
 */

#define ANTLR_VERSION	13333
#include "pcctscfg.h"
#include "pccts_stdio.h"

#include <string>
#include <iostream>
#include <map>
#include <list>
#include <vector>
#include <fstream>

using namespace std;

#include <stdio.h>
#include <stdlib.h>
#include "ptype.hh"
#include "symtab.hh"
#include "codegest.hh"

/// struct to contain information about a token.
typedef struct {
  string kind;
  string text;
  int line;
} Attrib;

/// function called by the scanner when a new token is found
/// Predeclared here, definition below.
void zzcr_attr(Attrib *attr,int type,char *text);

/// Include AST node fields declaration
#include "myASTnode.hh"

/// Macro called by the parser when a new AST node is to be created
/// createASTnode function doing the actual job is defined below.
#define zzcr_ast(as,attr,tttype,textt) as=createASTnode(attr,tttype,textt);
AST* createASTnode(Attrib* attr, int ttype, char *textt);
#include "antlr.h"
#include "ast.h"
#include "tokens.h"
#include "dlgdef.h"
LOOKAHEAD

void
#ifdef __USE_PROTOS
zzerraction(void)
#else
zzerraction()
#endif
{
	(*zzerr)("invalid token");
	zzadvance();
	zzskip();
}
>>


%%START

@
	<<
		NLA = INPUTEND;
	>>

PROGRAM
	<<
		NLA = PROGRAM;
	>>

ENDPROGRAM
	<<
		NLA = ENDPROGRAM;
	>>

VARS
	<<
		NLA = VARS;
	>>

ENDVARS
	<<
		NLA = ENDVARS;
	>>

INT
	<<
		NLA = INT;
	>>

BOOL
	<<
		NLA = BOOL;
	>>

STRUCT
	<<
		NLA = STRUCT;
	>>

ENDSTRUCT
	<<
		NLA = ENDSTRUCT;
	>>

WRITELN
	<<
		NLA = WRITELN;
	>>

PROCEDURE
	<<
		NLA = PROCEDURE;
	>>

ENDPROCEDURE
	<<
		NLA = ENDPROCEDURE;
	>>

val
	<<
		NLA = VAL;
	>>

ref
	<<
		NLA = REF;
	>>

\+
	<<
		NLA = PLUS;
	>>

\(
	<<
		NLA = OPENPAR;
	>>

\)
	<<
		NLA = CLOSEPAR;
	>>

:=
	<<
		NLA = ASIG;
	>>

.
	<<
		NLA = DOT;
	>>

,
	<<
		NLA = COMMA;
	>>

true|false
	<<
		NLA = BOOL_VAL;
	>>

[a-zA-Z][a-zA-Z0-9]*
	<<
		NLA = IDENT;
	>>

[0-9]+
	<<
		NLA = INTCONST;
	>>

//~[\n]*
	<<
		NLA = COMMENT;
    printf("%s",zzlextext); zzskip();   
	>>

[\ \t]+
	<<
		NLA = WHITESPACE;
    printf("%s",zzlextext); zzskip();   
	>>

\n
	<<
		NLA = NEWLINE;
    zzline++; printf("\n%3d: ", zzline); zzskip();   
	>>

~[]
	<<
		NLA = LEXICALERROR;
    printf("Lexical error: symbol '%s' ignored!\n", zzlextext);
    zzLexErrCount++;
    zzskip();   
	>>

%%
